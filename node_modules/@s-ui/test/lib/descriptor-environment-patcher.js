// List of test describers to be patched.
var functionsToPatch = ['describe', 'describe.only', 'it', 'it.only']; // List of environments, the environment define the function name. describe.client, describe.server

var environments = {
  CLIENT: 'client',
  SERVER: 'server'
};
var isNode = typeof process === 'object' && process.toString() === '[object process]';
export var descriptorsByEnvironmentPatcher = function descriptorsByEnvironmentPatcher() {
  /**
   * This function is the one with the purpose of handle and return the function that should be attached to our runOn{client | server} patch.
   * @param {Object} descriptor Is the object that contains the name of the descriptor base function and in the cases that we have nested function calls the nested name too
   * @param {String} env Can be one of the constants defined in the environments object - {SERVER, CLIENT}
   * @param {Boolean} isOnly A boolean function to know if we are trying to run a descriptor with the .only Function
   */
  function buildFunctionForEnv(_ref) {
    var descriptorName = _ref.descriptorName,
        firstLevelFnName = _ref.firstLevelFnName,
        env = _ref.env;
    var shouldReturnDescriber = isNode && env === environments.SERVER || !isNode && env === environments.CLIENT;
    var isOnlyServerButRunningAsClient = !isNode && env === environments.SERVER && firstLevelFnName;
    var isOnlyClientButRunningAsServer = isNode && env === environments.CLIENT && firstLevelFnName;

    if (shouldReturnDescriber) {
      return function () {
        var _global$descriptorNam, _global;

        firstLevelFnName ? (_global$descriptorNam = global[descriptorName])[firstLevelFnName].apply(_global$descriptorNam, arguments) : (_global = global)[descriptorName].apply(_global, arguments);
      };
    } else if (isOnlyClientButRunningAsServer || isOnlyServerButRunningAsClient) {
      return function () {
        throw new Error("Seems that you are doing a " + descriptorName + "." + env + ".only but you are running the tests for the " + (isNode ? environments.SERVER : environments.CLIENT) + "\n\n");
      };
    } else {
      return function (title) {
        return console.warn("skiping on the " + (isNode ? environments.SERVER : environments.CLIENT) + " '" + descriptorName + "('" + title + "')\n");
      };
    }
  }
  /**
   * The patchChainedFunction is the function that will handle to call the buildFunctionForEnv iterating for the environments to attach the function to each one
   * @param {Array} An array of two elements composed for the baseFnName (usually describe, it....) and a first depth level method (usually .only)
   */


  function patchChainedFunction(_ref2) {
    var descriptorName = _ref2[0],
        firstLevelFnName = _ref2[1];
    var baseFn = global[descriptorName];
    var environmentsKeys = Object.keys(environments);
    environmentsKeys.forEach(function (key) {
      var env = environments[key];
      baseFn["" + env][firstLevelFnName] = buildFunctionForEnv({
        descriptorName: descriptorName,
        firstLevelFnName: firstLevelFnName,
        env: env
      });
    });
  }
  /**
   * Patch base functions will
   * @param {String} descriptorName is a string with the name of the function to be patched.
   */


  function patchBaseFunctions(descriptorName) {
    var environmentsKeys = Object.keys(environments);
    environmentsKeys.forEach(function (key) {
      var env = environments[key];
      global[descriptorName]["" + env] = buildFunctionForEnv({
        descriptorName: descriptorName,
        env: env
      });
    });
  }
  /**
   * patchFunction is the entry method that will handle with the logic to know if is a depth descriptor patch or a baseDescriptor patch. Regarding on that will call one or another patching function
   * @param {String} fnName is a string with the name of the function to be patched.
   */


  function patchFunction(fnName) {
    var functionChainNames = fnName.split('.');
    var isOnly = functionChainNames.length > 1;
    isOnly ? patchChainedFunction(functionChainNames) : patchBaseFunctions(fnName);
  } // Init of our patcher.


  functionsToPatch.forEach(function (fnName) {
    return patchFunction(fnName);
  });
};