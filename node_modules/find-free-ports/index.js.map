{"version":3,"sources":["index.ts"],"names":["MIN_PORT","MAX_PORT","DEFAULT_JOB_COUNT","os","cpus","length","clamp","value","min","max","findFreePorts","count","endPort","startPort","jobCount","isFree","isFreePort","Error","portInterval","Math","ceil","ports","jobPromises","i","push","scanRange","Promise","all","port","accept","reject","sock","net","createConnection","once","end","e","destroy","code"],"mappings":";;;;;;;;;AACA;;AACA;;;;AAEA,MAAMA,QAAQ,GAAG,IAAjB;AACA,MAAMC,QAAQ,GAAG,KAAjB;;AACA,MAAMC,iBAAiB,GAAGC,YAAGC,IAAH,GAAUC,MAApC;;AASA,SAASC,KAAT,CAAeC,KAAf,EAA8BC,GAA9B,EAA2CC,GAA3C,EAAgE;AAC9D,MAAIF,KAAK,GAAGC,GAAZ,EAAiB,OAAOA,GAAP;AACjB,MAAID,KAAK,GAAGE,GAAZ,EAAiB,OAAOA,GAAP;AACjB,SAAOF,KAAP;AACD;;AAEM,eAAeG,aAAf,CAA6BC,KAAK,GAAG,CAArC,EAAwC;AAC7CC,EAAAA,OAAO,GAAGX,QADmC;AAE7CY,EAAAA,SAAS,GAAGb,QAFiC;AAG7Cc,EAAAA,QAAQ,GAAGZ,iBAHkC;AAI7Ca,EAAAA,MAAM,GAAGC;AAJoC,IAKrB,EALnB,EAK0C;AAE/C,MAAIL,KAAK,GAAIC,OAAO,GAAGC,SAAvB,EAAmC;AACjC,UAAM,IAAII,KAAJ,CAAW,sHAAX,CAAN;AACD;;AAED,QAAMC,YAAY,GAAGC,IAAI,CAACC,IAAL,CAAU,CAACR,OAAO,GAAGC,SAAX,IAAwBC,QAAlC,CAArB;AAEA,QAAMO,KAAe,GAAG,EAAxB;AACA,QAAMC,WAAiC,GAAG,EAA1C;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,QAApB,EAA8BS,CAAC,EAA/B,EAAmC;AACjCD,IAAAA,WAAW,CAACE,IAAZ,CAAiBC,SAAS,CAACZ,SAAS,GAAGK,YAAY,GAAGK,CAA5B,EAA+BJ,IAAI,CAACX,GAAL,CAASI,OAAT,EAAkBC,SAAS,GAAGK,YAAY,IAAIK,CAAC,GAAC,CAAN,CAA1C,CAA/B,CAA1B;AACD;;AAED,QAAMG,OAAO,CAACC,GAAR,CAAYL,WAAZ,CAAN;;AAEA,MAAID,KAAK,CAAChB,MAAN,GAAeM,KAAnB,EAA0B;AACxB,UAAM,IAAIM,KAAJ,CAAW,mEAAX,CAAN;AACD;;AAED,SAAOI,KAAP;;AAEA,iBAAeI,SAAf,CAAyBZ,SAAzB,EAA4CD,OAA5C,EAA6D;AAC3D,SAAK,IAAIgB,IAAI,GAAGf,SAAhB,EAA2Be,IAAI,GAAGhB,OAAlC,EAA2CgB,IAAI,EAA/C,EAAmD;AACjD,UAAIP,KAAK,CAAChB,MAAN,IAAgBM,KAApB,EAA2B;AACzB;AACD;;AACD,UAAI,MAAMI,MAAM,CAACa,IAAD,CAAhB,EAAwB;AAEtB,YAAIP,KAAK,CAAChB,MAAN,IAAgBM,KAApB,EAA2B;AACzB;AACD;;AACDU,QAAAA,KAAK,CAACG,IAAN,CAAWI,IAAX;AACD;AACF;AACF;AAEF;;AAEM,SAASZ,UAAT,CAAoBY,IAApB,EAAoD;AACzD,SAAO,IAAIF,OAAJ,CAAY,CAACG,MAAD,EAASC,MAAT,KAAoB;AACrC,UAAMC,IAAI,GAAGC,aAAIC,gBAAJ,CAAqBL,IAArB,CAAb;;AACAG,IAAAA,IAAI,CAACG,IAAL,CAAU,SAAV,EAAqB,MAAM;AAAEH,MAAAA,IAAI,CAACI,GAAL;AAAYN,MAAAA,MAAM,CAAC,KAAD,CAAN;AAAgB,KAAzD;AACAE,IAAAA,IAAI,CAACG,IAAL,CAAU,OAAV,EAAoBE,CAAD,IAA8B;AAC/CL,MAAAA,IAAI,CAACM,OAAL;;AACA,UAAID,CAAC,CAACE,IAAF,KAAW,cAAf,EAA+B;AAC7BT,QAAAA,MAAM,CAAC,IAAD,CAAN;AACD,OAFD,MAEO;AACLC,QAAAA,MAAM,CAACM,CAAD,CAAN;AACD;AACF,KAPD;AAQD,GAXM,CAAP;AAYD;;eAEc1B,a","sourcesContent":["\nimport os from \"os\"\nimport net from \"net\"\n\nconst MIN_PORT = 1025;\nconst MAX_PORT = 65535;\nconst DEFAULT_JOB_COUNT = os.cpus().length;\n\nexport interface FindFreePortsOptions {\n  startPort?: number;\n  endPort?: number;\n  jobCount?: number;\n  isFree?: (port: number) => Promise<boolean>;\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n}\n\nexport async function findFreePorts(count = 1, {\n  endPort = MAX_PORT,\n  startPort = MIN_PORT,\n  jobCount = DEFAULT_JOB_COUNT,\n  isFree = isFreePort\n}: FindFreePortsOptions = {}): Promise<number[]> {\n\n  if (count > (endPort - startPort)) {\n    throw new Error(`Could not find free ports: the range of allowed ports is not large enough for the requested amount of ports to find.`);\n  }\n\n  const portInterval = Math.ceil((endPort - startPort) / jobCount);\n\n  const ports: number[] = [];\n  const jobPromises: Array<Promise<void>> = [];\n\n  for (let i = 0; i < jobCount; i++) {\n    jobPromises.push(scanRange(startPort + portInterval * i, Math.min(endPort, startPort + portInterval * (i+1))));\n  }\n\n  await Promise.all(jobPromises);\n\n  if (ports.length < count) {\n    throw new Error(`Could not find free ports: there were not enough ports available.`);\n  }\n\n  return ports;\n\n  async function scanRange(startPort: number, endPort: number) {\n    for (let port = startPort; port < endPort; port++) {\n      if (ports.length >= count) {\n        break;\n      }\n      if (await isFree(port)) {\n\n        if (ports.length >= count) {\n          break;\n        }\n        ports.push(port);\n      }\n    }\n  }\n\n}\n\nexport function isFreePort(port: number): Promise<boolean> {\n  return new Promise((accept, reject) => {\n    const sock = net.createConnection(port);\n    sock.once('connect', () => { sock.end(); accept(false); });\n    sock.once('error', (e: NodeJS.ErrnoException) => {\n      sock.destroy();\n      if (e.code === 'ECONNREFUSED') {\n        accept(true)\n      } else {\n        reject(e);\n      }\n    });\n  });\n}\n\nexport default findFreePorts;\n\n"],"file":"index.js"}