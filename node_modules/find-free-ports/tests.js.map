{"version":3,"sources":["tests.ts"],"names":["PORT_COUNT","isUnique","array","set","Set","element","has","add","listen","server","port","Promise","accept","reject","once","address","closeServer","close","err","t","throwsAsync","startPort","endPort","ports","assert","length","truthy","jobCount","plan","net","createServer","undefined","falsy"],"mappings":";;AACA;;AAEA;;AAEA;;;;AAEA,MAAMA,UAAU,GAAG,IAAnB;;AAEA,SAASC,QAAT,CAAqBC,KAArB,EAA0C;AACxC,QAAMC,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;AACA,OAAK,MAAMC,OAAX,IAAsBH,KAAtB,EAA6B;AAC3B,QAAIC,GAAG,CAACG,GAAJ,CAAQD,OAAR,CAAJ,EAAsB;AACpB,aAAO,KAAP;AACD;;AACDF,IAAAA,GAAG,CAACI,GAAJ,CAAQF,OAAR;AACD;;AACD,SAAO,IAAP;AACD;;AAED,SAASG,MAAT,CAAgBC,MAAhB,EAAoCC,IAApC,EAAoE;AAClE,SAAO,IAAIC,OAAJ,CAAY,CAACC,MAAD,EAASC,MAAT,KAAoB;AACrCJ,IAAAA,MAAM,CAACK,IAAP,CAAY,OAAZ,EAAqBD,MAArB;AACAJ,IAAAA,MAAM,CAACD,MAAP,CAAcE,IAAd,EAAoB,MAAM;AACxBE,MAAAA,MAAM,CAAEH,MAAM,CAACM,OAAP,EAAD,CAAsCL,IAAvC,CAAN;AACD,KAFD;AAGD,GALM,CAAP;AAMD;;AAED,SAASM,WAAT,CAAqBP,MAArB,EAAyC;AACvC,SAAO,IAAIE,OAAJ,CAAkB,CAACC,MAAD,EAASC,MAAT,KAAoB;AAC3CJ,IAAAA,MAAM,CAACQ,KAAP,CAAaC,GAAG,IAAI;AAClB,UAAIA,GAAJ,EAAS;AACPL,QAAAA,MAAM,CAACK,GAAD,CAAN;AACD,OAFD,MAEO;AACLN,QAAAA,MAAM;AACP;AACF,KAND;AAOD,GARM,CAAP;AASD;;AAGD,kBAAK,8FAAL,EAAqG,MAAOO,CAAP,IAAa;AAChH,QAAMA,CAAC,CAACC,WAAF,CAAc,MAAM,0BAAc,EAAd,EAAkB;AAAEC,IAAAA,SAAS,EAAE;AAAb,GAAlB,CAApB,CAAN;AACA,QAAMF,CAAC,CAACC,WAAF,CAAc,MAAM,0BAAc,CAAd,EAAiB;AAAEC,IAAAA,SAAS,EAAE,IAAb;AAAmBC,IAAAA,OAAO,EAAE;AAA5B,GAAjB,CAApB,CAAN;AACD,CAHD;AAKA,kBAAK,kCAAL,EAAyC,MAAOH,CAAP,IAAa;AACpD,QAAMI,KAAK,GAAG,MAAM,2BAApB;AACAJ,EAAAA,CAAC,CAACK,MAAF,CAASD,KAAK,CAACE,MAAN,KAAiB,CAA1B;AACAN,EAAAA,CAAC,CAACO,MAAF,CAAS,MAAM,uBAAWH,KAAK,CAAC,CAAD,CAAhB,CAAf;AACD,CAJD;AAMA,kBAAK,qCAAL,EAA4C,MAAOJ,CAAP,IAAa;AACvD,QAAMI,KAAK,GAAG,MAAM,0BAAc,CAAd,CAApB;AACAJ,EAAAA,CAAC,CAACK,MAAF,CAASD,KAAK,CAACE,MAAN,KAAiB,CAA1B;AACAN,EAAAA,CAAC,CAACK,MAAF,CAASvB,QAAQ,CAACsB,KAAD,CAAjB;AACD,CAJD;AAMA,kBAAK,8CAAL,EAAqD,MAAOJ,CAAP,IAAa;AAChE,QAAMI,KAAK,GAAG,MAAM,0BAAcvB,UAAd,CAApB;AACAmB,EAAAA,CAAC,CAACK,MAAF,CAASD,KAAK,CAACE,MAAN,KAAiBzB,UAA1B;AACAmB,EAAAA,CAAC,CAACO,MAAF,CAASzB,QAAQ,CAACsB,KAAD,CAAjB;AACD,CAJD;AAMA,kBAAK,qCAAL,EAA4C,MAAOJ,CAAP,IAAa;AACvD,QAAMI,KAAK,GAAG,MAAM,0BAAcvB,UAAd,EAA0B;AAAE2B,IAAAA,QAAQ,EAAE;AAAZ,GAA1B,CAApB;AACAR,EAAAA,CAAC,CAACK,MAAF,CAASD,KAAK,CAACE,MAAN,KAAiBzB,UAA1B;AACAmB,EAAAA,CAAC,CAACO,MAAF,CAASzB,QAAQ,CAACsB,KAAD,CAAjB;AACD,CAJD;AAMA,kBAAK,+BAAL,EAAsC,MAAOJ,CAAP,IAAa;AACjD,QAAMI,KAAK,GAAG,MAAM,0BAAcvB,UAAd,EAA0B;AAAE2B,IAAAA,QAAQ,EAAE;AAAZ,GAA1B,CAApB;AACAR,EAAAA,CAAC,CAACK,MAAF,CAASD,KAAK,CAACE,MAAN,KAAiBzB,UAA1B;AACAmB,EAAAA,CAAC,CAACO,MAAF,CAASzB,QAAQ,CAACsB,KAAD,CAAjB;AACD,CAJD;AAMA,kBAAK,wCAAL,EAA+C,MAAOJ,CAAP,IAAa;AAC1DA,EAAAA,CAAC,CAACS,IAAF,CAAO,CAAP;;AACA,QAAMnB,MAAM,GAAGoB,aAAIC,YAAJ,EAAf;;AACA,QAAMpB,IAAI,GAAG,MAAMF,MAAM,CAACC,MAAD,EAASsB,SAAT,CAAzB;AACAZ,EAAAA,CAAC,CAACa,KAAF,CAAQ,MAAM,uBAAWtB,IAAX,CAAd;AACA,QAAMM,WAAW,CAACP,MAAD,CAAjB;AACD,CAND;AAQA,kBAAK,sCAAL,EAA6C,MAAOU,CAAP,IAAa;AACxDA,EAAAA,CAAC,CAACS,IAAF,CAAO,CAAP;;AACA,QAAMnB,MAAM,GAAGoB,aAAIC,YAAJ,EAAf;;AACA,QAAMpB,IAAI,GAAG,MAAMF,MAAM,CAACC,MAAD,CAAzB;AACA,QAAMO,WAAW,CAACP,MAAD,CAAjB;AACAU,EAAAA,CAAC,CAACO,MAAF,CAAS,MAAM,uBAAWhB,IAAX,CAAf;AACD,CAND","sourcesContent":["\nimport test from \"ava\"\n\nimport net from \"net\"\n\nimport { findFreePorts, isFreePort } from './index';\n\nconst PORT_COUNT = 1000;\n\nfunction isUnique<T>(array: T[]): boolean {\n  const set = new Set();\n  for (const element of array) {\n    if (set.has(element)) {\n      return false;\n    }\n    set.add(element);\n  }\n  return true;\n}\n\nfunction listen(server: net.Server, port?: number): Promise<number> {\n  return new Promise((accept, reject) => {\n    server.once('error', reject);\n    server.listen(port, () => {\n      accept((server.address() as net.AddressInfo).port);\n    });\n  });\n}\n\nfunction closeServer(server: net.Server) {\n  return new Promise<void>((accept, reject) => {\n    server.close(err => {\n      if (err) {\n        reject(err);\n      } else {\n        accept();\n      }\n    });\n  });\n}\n\n\ntest('findFreePorts() crashes properly when there are not enough free ports within the given range', async (t) => {\n  await t.throwsAsync(() => findFreePorts(10, { startPort: 65530 }));\n  await t.throwsAsync(() => findFreePorts(3, { startPort: 1024, endPort: 1026 }));\n})\n\ntest('searches for one port by default', async (t) => {\n  const ports = await findFreePorts();\n  t.assert(ports.length === 1);\n  t.truthy(await isFreePort(ports[0]));\n});\n\ntest('can find a few ports when requested', async (t) => {\n  const ports = await findFreePorts(3);\n  t.assert(ports.length === 3);\n  t.assert(isUnique(ports));\n});\n\ntest('can find a large amount of unique free ports', async (t) => {\n  const ports = await findFreePorts(PORT_COUNT);\n  t.assert(ports.length === PORT_COUNT);\n  t.truthy(isUnique(ports));\n});\n\ntest('can run with only one job specified', async (t) => {\n  const ports = await findFreePorts(PORT_COUNT, { jobCount: 1 });\n  t.assert(ports.length === PORT_COUNT);\n  t.truthy(isUnique(ports));\n});\n\ntest('can run with exactly two jobs', async (t) => {\n  const ports = await findFreePorts(PORT_COUNT, { jobCount: 2 });\n  t.assert(ports.length === PORT_COUNT);\n  t.truthy(isUnique(ports));\n});\n\ntest('isFree() detects when a port is in use', async (t) => {\n  t.plan(1);\n  const server = net.createServer();\n  const port = await listen(server, undefined);\n  t.falsy(await isFreePort(port));\n  await closeServer(server);\n});\n\ntest('isFree() detects when a port is free', async (t) => {\n  t.plan(1);\n  const server = net.createServer();\n  const port = await listen(server);\n  await closeServer(server);\n  t.truthy(await isFreePort(port));\n});\n\n"],"file":"tests.js"}